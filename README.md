# LOQ Interpreter in Rust

## Overview

This project is an interpreter for a simple language called LOQ, written in Rust. The LOQ language supports basic arithmetic operations, variable declarations, and print statements. The project is structured into three main modules: lexer, parser, and interpreter, each responsible for a different stage of the interpretation process.

## Project Structure

```
loq_interpreter/
├── src/
│   ├── lexer.rs
│   ├── parser.rs
│   ├── interpreter.rs
│   ├── main.rs
├── Cargo.toml
```

## Modules

1. **Lexer (`lexer.rs`)**
2. **Parser (`parser.rs`)**
3. **Interpreter (`interpreter.rs`)**

### 1. Lexer (`lexer.rs`)

The lexer is responsible for converting the input source code into a sequence of tokens. Each token represents a basic syntactic unit such as a keyword, identifier, operator, or literal.

#### Token Enum

The `Token` enum represents the different types of tokens that can be identified in the source code.

#### Lexer Struct

The `Lexer` struct holds the input characters and the current position in the input.

#### Lexer Implementation

The lexer implementation includes methods for tokenizing the input.

- **new**: Creates a new lexer with the given input.
- **next_token**: Retrieves the next token from the input.
- **match_keyword**: Checks if the current input matches a specific keyword.
- **read_identifier**: Reads an identifier from the input.
- **read_number**: Reads a number from the input.
- **skip_whitespace**: Skips whitespace characters in the input.

### 2. Parser (`parser.rs`)

The parser converts the sequence of tokens into an Abstract Syntax Tree (AST), which represents the hierarchical structure of the source code.

#### ASTNode Enum

The `ASTNode` enum represents the different types of nodes in the AST.

#### Parser Struct

The `Parser` struct holds the lexer and the current token.

#### Parser Implementation

The parser implementation includes methods for parsing the input into an AST.

- **new**: Creates a new parser with the given lexer.
- **parse**: Parses the entire input and returns a list of AST nodes.
- **parse_statement**: Parses a single statement.
- **parse_expression**: Parses an expression.
- **parse_term**: Parses a term in an expression.
- **parse_factor**: Parses a factor in a term.
- **parse_expression_statement**: Parses an expression statement.
- **next_token**: Advances to the next token.
- **expect_token**: Expects a specific token and advances to the next token.

### 3. Interpreter (`interpreter.rs`)

The interpreter executes the AST generated by the parser.

#### Interpreter Struct

The `Interpreter` struct holds the variable environment, which maps variable names to their values.

#### Interpreter Implementation

The interpreter implementation includes methods for interpreting the AST.

- **new**: Creates a new interpreter with an empty environment.
- **interpret**: Interprets a list of AST nodes.
- **eval**: Evaluates a single AST node and returns its value.
- **eval_binary_op**: Evaluates a binary operation.
- **eval_print**: Evaluates a print statement.
- **eval_println**: Evaluates a println statement.
- **eval_variable_declaration**: Evaluates a variable declaration.

### Main File (`main.rs`)

The `main.rs` file contains the entry point of the program. It creates the interpreter, reads user input, and executes the input using the interpreter.

### Explanation

1. **Lexer (`lexer.rs`)**:
    - **Purpose**: Tokenizes the input source code.
    - **Approach**: Reads characters from the input and converts them into tokens.
    - **Functions**:
        - `new`: Initializes the lexer with the input string.
        - `next_token`: Retrieves the next token from the input.
        - `match_keyword`: Matches specific keywords (`pn`, `pnl`, `let`).
        - `read_identifier`: Reads and returns an identifier token.
        - `read_number`: Reads and returns a number token.
        - `skip_whitespace`: Skips over whitespace characters.

2. **Parser (`parser.rs`)**:
    - **Purpose**: Converts tokens into an AST.
    - **Approach**: Parses tokens based on grammar rules and constructs an AST.
    - **Functions**:
        - `new`: Initializes the parser with the lexer.
        - `parse`: Parses the entire input and returns a list of AST nodes.
        - `parse_statement`: Parses a single statement.
        - `parse_expression`: Parses an expression.
        - `parse_term`: Parses a term in an expression.
        - `parse_factor`: Parses a factor in a term.
        - `parse_expression_statement`: Parses an expression statement.
        - `next_token`: Advances to the next token.
        - `expect_token`: Checks for a specific token and advances.

3. **Interpreter (`interpreter.rs`)**:
    - **Purpose**: Executes the AST.
    - **Approach**: Evaluates each node in the AST and performs corresponding actions.
    - **Functions**:
        - `new`: Initializes the interpreter with an empty environment.
        - `interpret`: Interprets a list of AST nodes.
        - `eval`: Evaluates a single AST node.
        - `eval_binary_op`: Evaluates binary operations.
        - `eval_print`: Evaluates print statements.
        - `eval_println`: Evaluates println statements.
        - `eval_variable_declaration`: Evaluates variable declarations.

4. **Main File (`main.rs`)**:
    - **Purpose**: Entry point of the program.
    - **Approach**: Reads user input and processes it using the lexer, parser, and interpreter.
    - **Functions**:
        - `main`: Main function that runs the interpreter loop.

### Usage

1. **Run the Project**:

   ```sh
   cargo build
   cargo run
   ```

2. **Enter Commands**:

   ```sh
   LOQ> let x = 5;
   LOQ> pn x;
   LOQ> pnl 10 + 20;
   LOQ> exit
   ```